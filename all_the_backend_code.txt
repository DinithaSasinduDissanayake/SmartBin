// File: c:\y2s2ITP\SmartBin\backend\package.json
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "directories": {
    "test": "tests"
  },
  "scripts": {
    "test": "jest",
    "start": "node src/server.js",
    "dev": "nodemon src/server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "bcryptjs": "^3.0.2",
    "compression": "^1.8.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-validator": "^7.2.1",
    "helmet": "^8.0.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.12.1",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.2"
  },
  "devDependencies": {
    "eslint": "^9.22.0",
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "supertest": "^7.0.0"
  }
}




// File: C:\y2s2ITP\SmartBin\backend\src\server.js
// In src/server.js
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
require('dotenv').config();
const path = require('path');
const fs = require('fs');

const app = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(morgan('dev'));

// Import routes
const authRoutes = require('./routes/authRoutes');
const userRoutes = require('./routes/userRoutes');
const subscriptionPlanRoutes = require('./routes/subscriptionPlanRoutes');
const documentRoutes = require('./routes/documentRoutes');
const attendanceRoutes = require('./routes/attendanceRoutes');
const performanceRoutes = require('./routes/performanceRoutes');
const financialRoutes = require('./routes/financialRoutes'); // Import financial routes
const userSubscriptionRoutes = require('./routes/userSubscriptionRoutes'); // Import user subscription routes

// Use routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/subscription-plans', subscriptionPlanRoutes);
app.use('/api/documents', documentRoutes);
app.use('/api/attendance', attendanceRoutes);
app.use('/api/performance', performanceRoutes);
app.use('/api/financials', financialRoutes); // Use financial routes
app.use('/api/user-subscriptions', userSubscriptionRoutes); // Mount user subscription routes

// Basic route for testing
app.get('/', (req, res) => {
  res.json({ message: 'SmartBin API is running' });
});

// Ensure you have this directory for uploads
const uploadDir = path.join(__dirname, '../uploads/documents');
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

// Make the uploads directory accessible
app.use('/uploads', express.static(path.join(__dirname, '../uploads')));

// Connect to MongoDB
const MONGODB_URI = process.env.MONGODB_URI;
mongoose
  .connect(MONGODB_URI)
  .then(() => console.log('Connected to MongoDB'))
  .catch((err) => console.error('MongoDB connection error:', err));

// Global Error Handler
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});

// Start server
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));



// File: C:\y2s2ITP\SmartBin\backend\src\controllers\attendanceController.js
const Attendance = require('../models/Attendance');
const User = require('../models/User');

// @desc    Record check-in for staff
// @route   POST /api/attendance/check-in
// @access  Private/Staff
exports.checkIn = async (req, res) => {
  try {
    // Check if user is staff
    if (req.user.role !== 'staff' && req.user.role !== 'admin') {
      return res.status(403).json({ message: 'Only staff can check in' });
    }
    
    // Check if already checked in today
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    const existingRecord = await Attendance.findOne({
      staff: req.user.id,
      date: {
        $gte: today,
        $lt: tomorrow
      }
    });
    
    if (existingRecord && !existingRecord.checkOutTime) {
      return res.status(400).json({ message: 'You are already checked in' });
    }
    
    // Create new attendance record
    const attendance = new Attendance({
      staff: req.user.id,
      checkInTime: new Date(),
      date: new Date()
    });
    
    await attendance.save();
    
    res.status(201).json(attendance);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Record check-out for staff
// @route   PUT /api/attendance/check-out
// @access  Private/Staff
exports.checkOut = async (req, res) => {
  try {
    // Check if user is staff
    if (req.user.role !== 'staff' && req.user.role !== 'admin') {
      return res.status(403).json({ message: 'Only staff can check out' });
    }
    
    // Find today's check-in record
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    const record = await Attendance.findOne({
      staff: req.user.id,
      date: {
        $gte: today,
        $lt: tomorrow
      },
      checkOutTime: { $exists: false }
    });
    
    if (!record) {
      return res.status(400).json({ message: 'No active check-in found for today' });
    }
    
    // Update checkout time
    record.checkOutTime = new Date();
    
    await record.save();
    
    res.json(record);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Get staff attendance by date range
// @route   GET /api/attendance
// @access  Private/Staff
exports.getMyAttendance = async (req, res) => {
  try {
    const { startDate, endDate } = req.query;
    
    let query = { staff: req.user.id };
    
    if (startDate && endDate) {
      query.date = {
        $gte: new Date(startDate),
        $lte: new Date(endDate)
      };
    }
    
    const attendance = await Attendance.find(query).sort({ date: -1 });
    
    res.json(attendance);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Get all staff attendance (for admin)
// @route   GET /api/attendance/all
// @access  Private/Admin
exports.getAllAttendance = async (req, res) => {
  try {
    const { startDate, endDate, staffId } = req.query;
    
    let query = {};
    
    if (staffId) {
      query.staff = staffId;
    }
    
    if (startDate && endDate) {
      query.date = {
        $gte: new Date(startDate),
        $lte: new Date(endDate)
      };
    }
    
    const attendance = await Attendance.find(query)
      .populate('staff', 'name email')
      .sort({ date: -1 });
    
    res.json(attendance);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Update attendance record (for admin)
// @route   PUT /api/attendance/:id
// @access  Private/Admin
exports.updateAttendance = async (req, res) => {
  try {
    const { checkInTime, checkOutTime, status, notes } = req.body;
    
    const attendance = await Attendance.findById(req.params.id);
    
    if (!attendance) {
      return res.status(404).json({ message: 'Attendance record not found' });
    }
    
    // Update fields
    if (checkInTime) attendance.checkInTime = checkInTime;
    if (checkOutTime) attendance.checkOutTime = checkOutTime;
    if (status) attendance.status = status;
    if (notes !== undefined) attendance.notes = notes;
    
    await attendance.save();
    
    res.json(attendance);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Get staff attendance summary
// @route   GET /api/attendance/summary
// @access  Private/Admin
exports.getAttendanceSummary = async (req, res) => {
  try {
    const { month, year } = req.query;
    
    // Default to current month if not specified
    const currentDate = new Date();
    const targetMonth = month ? parseInt(month) - 1 : currentDate.getMonth();
    const targetYear = year ? parseInt(year) : currentDate.getFullYear();
    
    const startDate = new Date(targetYear, targetMonth, 1);
    const endDate = new Date(targetYear, targetMonth + 1, 0);
    
    // Get all staff members
    const staffMembers = await User.find({ role: 'staff' }, '_id name email');
    
    // Get attendance for each staff
    const summaries = [];
    
    for (const staff of staffMembers) {
      const records = await Attendance.find({
        staff: staff._id,
        date: {
          $gte: startDate,
          $lte: endDate
        }
      });
      
      // Calculate stats
      let totalHours = 0;
      let presentDays = 0;
      let absentDays = 0;
      let lateDays = 0;
      
      records.forEach(record => {
        totalHours += record.totalHours || 0;
        
        if (record.status === 'Present') presentDays++;
        else if (record.status === 'Absent') absentDays++;
        else if (record.status === 'Late') lateDays++;
      });
      
      summaries.push({
        staff: {
          _id: staff._id,
          name: staff.name,
          email: staff.email
        },
        summary: {
          totalHours,
          presentDays,
          absentDays,
          lateDays,
          totalRecords: records.length
        }
      });
    }
    
    res.json(summaries);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};



// File: C:\y2s2ITP\SmartBin\backend\src\controllers\authController.js
// backend/src/controllers/authController.js
const User = require('../models/User');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs'); // Add bcrypt import

// Generate JWT token
const generateToken = (id) => {
  return jwt.sign({ id }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRE || '30d'
  });
};

// @desc    Register user
// @route   POST /api/auth/register
// @access  Public
exports.registerUser = async (req, res) => {
  try {
    const { name, email, password } = req.body;
    
    // Check if user exists
    const userExists = await User.findOne({ email });

    if (userExists) {
      return res.status(400).json({ message: 'User already exists' });
    }

    // Create user with default role
    const user = await User.create({
      name,
      email,
      password,
      // No need to specify role - it will use the default from the model
    });

    if (user) {
      res.status(201).json({
        _id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
        token: generateToken(user._id)
      });
    } else {
      res.status(400).json({ message: 'Invalid user data' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Login user
// @route   POST /api/auth/login
// @access  Public
exports.loginUser = async (req, res) => {
  try {
    console.log('Login attempt received');
    
    const { email, password } = req.body;
    
    // IMPORTANT CHANGE: Add .select('+password') to include the password field
    const user = await User.findOne({ 
      email: { $regex: new RegExp(`^${email}$`, 'i') } 
    }).select('+password');
    
    if (!user) {
      console.log(`User not found: ${email}`);
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    console.log(`User found: ${user.email}, role: ${user.role}`);
    
    // Use the model's matchPassword method instead of direct bcrypt
    const isMatch = await user.matchPassword(password);
    console.log(`Password match result: ${isMatch}`);
    
    if (!isMatch) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    
    // Generate token and send response
    const token = generateToken(user._id);
    
    res.json({
      _id: user._id,
      name: user.name,
      email: user.email,
      role: user.role,
      token
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Get current logged in user
// @route   GET /api/auth/me
// @access  Private
exports.getMe = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    
    res.json({
      _id: user._id,
      name: user.name,
      email: user.email,
      role: user.role
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};



// File: C:\y2s2ITP\SmartBin\backend\src\controllers\documentController.js
const Document = require('../models/Document');
const User = require('../models/User');
const path = require('path');
const fs = require('fs');

// @desc    Upload new document
// @route   POST /api/documents/upload
// @access  Private
exports.uploadDocument = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }
    
    // Create new document
    const document = await Document.create({
      user: req.user.id,
      name: req.body.name || req.file.originalname,
      type: req.body.type || 'Other',
      filePath: req.file.path,
      mimeType: req.file.mimetype,
      size: req.file.size
    });
    
    res.status(201).json(document);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Get all user documents
// @route   GET /api/documents
// @access  Private
exports.getUserDocuments = async (req, res) => {
  try {
    const documents = await Document.find({ user: req.user.id });
    res.json(documents);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Get document by ID
// @route   GET /api/documents/:id
// @access  Private
exports.getDocumentById = async (req, res) => {
  try {
    const document = await Document.findById(req.params.id);
    
    if (!document) {
      return res.status(404).json({ message: 'Document not found' });
    }
    
    // Check if the document belongs to the user
    if (document.user.toString() !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ message: 'Not authorized to access this document' });
    }
    
    res.json(document);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Delete document
// @route   DELETE /api/documents/:id
// @access  Private
exports.deleteDocument = async (req, res) => {
  try {
    const document = await Document.findById(req.params.id);
    
    if (!document) {
      return res.status(404).json({ message: 'Document not found' });
    }
    
    // Check if the document belongs to the user
    if (document.user.toString() !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ message: 'Not authorized to delete this document' });
    }
    
    // Delete file from storage
    if (fs.existsSync(document.filePath)) {
      fs.unlinkSync(document.filePath);
    }
    
    // Delete document from database
    await document.deleteOne();
    
    res.json({ message: 'Document deleted successfully' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Verify document (admin only)
// @route   PUT /api/documents/:id/verify
// @access  Private/Admin
exports.verifyDocument = async (req, res) => {
  try {
    const document = await Document.findById(req.params.id);
    
    if (!document) {
      return res.status(404).json({ message: 'Document not found' });
    }
    
    document.verificationStatus = req.body.status || 'Verified';
    document.verificationDate = Date.now();
    document.verificationNotes = req.body.notes || '';
    
    const updatedDocument = await document.save();
    
    res.json(updatedDocument);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};



// File: C:\y2s2ITP\SmartBin\backend\src\controllers\financialController.js
const SubscriptionPlan = require('../models/SubscriptionPlan');
const Payment = require('../models/Payment');
const Expense = require('../models/Expense');
const UserSubscription = require('../models/UserSubscription');
const User = require('../models/User');

// Helper function to add months
const addMonths = (date, months) => {
    const d = new Date(date);
    d.setMonth(d.getMonth() + months);
    // Handle edge case where the day doesn't exist in the target month
    if (d.getDate() < date.getDate()) {
        d.setDate(0); // Go to the last day of the previous month
    }
    return d;
};

// Helper function to get number of days in a period
const getDaysInPeriod = (start, end) => {
    return Math.ceil((end - start) / (1000 * 60 * 60 * 24));
};

exports.getDashboardData = async (req, res) => {
    try {
        // Get date range from query parameter (default: month)
        const dateRange = req.query.range || 'month';
        
        // Calculate date ranges based on the parameter
        const currentDate = new Date();
        let startDate;
        let previousStartDate, previousEndDate;
        let numberOfDaysInPeriod;

        switch (dateRange) {
            case 'year':
                startDate = new Date(currentDate.getFullYear(), 0, 1); // Jan 1 of current year
                previousStartDate = new Date(currentDate.getFullYear() - 1, 0, 1);
                previousEndDate = new Date(currentDate.getFullYear() - 1, 11, 31);
                numberOfDaysInPeriod = getDaysInPeriod(startDate, currentDate); // Days so far this year
                break;
            case 'last3months':
                // Calculate start date as 3 months ago from current date
                startDate = new Date(currentDate);
                startDate.setMonth(currentDate.getMonth() - 2, 1); // First day of the month 2 months ago
                
                // Calculate previous period (3 months before the current 3-month period)
                previousStartDate = new Date(startDate);
                previousStartDate.setMonth(startDate.getMonth() - 3);
                previousEndDate = new Date(startDate.getTime() - 1); // Day before start date
                
                numberOfDaysInPeriod = getDaysInPeriod(startDate, currentDate);
                break;
            case 'month':
            default:
                startDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1); // 1st of current month
                previousStartDate = addMonths(startDate, -1);
                previousEndDate = new Date(startDate.getTime() - 1); // End of previous month
                numberOfDaysInPeriod = currentDate.getDate(); // Days so far this month
                break;
        }
        const yearStartDate = new Date(currentDate.getFullYear(), 0, 1);
        
        // 1. Count Active Subscriptions (Total, not period-specific)
        const activeSubscriptions = await UserSubscription.countDocuments({ 
            status: 'active' 
        });

        // Count New Subscriptions in the period
        const newSubscriptions = await UserSubscription.countDocuments({
            startDate: { $gte: startDate, $lte: currentDate }
        });

        // Count Cancellations in the period 
        const cancellations = await UserSubscription.countDocuments({
            status: 'cancelled',
            updatedAt: { $gte: startDate, $lte: currentDate }
        });
        
        // 2. Calculate Revenue
        // Current period revenue
        const periodRevenueResult = await Payment.aggregate([
            { $match: { status: 'completed', paymentDate: { $gte: startDate, $lte: currentDate } } },
            { $group: { _id: null, total: { $sum: "$amount" } } }
        ]);
        const periodRevenue = periodRevenueResult.length > 0 ? periodRevenueResult[0].total : 0;

        // Previous period revenue
        const previousPeriodRevenueResult = await Payment.aggregate([
            { $match: { status: 'completed', paymentDate: { $gte: previousStartDate, $lte: previousEndDate } } },
            { $group: { _id: null, total: { $sum: "$amount" } } }
        ]);
        const previousPeriodRevenue = previousPeriodRevenueResult.length > 0 ? previousPeriodRevenueResult[0].total : 0;

        // Calculate Revenue Growth Percentage
        let revenueGrowthPercentage = 0;
        if (previousPeriodRevenue > 0) {
            revenueGrowthPercentage = ((periodRevenue - previousPeriodRevenue) / previousPeriodRevenue) * 100;
        } else if (periodRevenue > 0) {
            revenueGrowthPercentage = 100; // Growth is 100% if previous was 0 and current is positive
        }

        // Calculate Average Daily Revenue
        const averageDailyRevenue = numberOfDaysInPeriod > 0 ? periodRevenue / numberOfDaysInPeriod : 0;

        // Year-to-date revenue
        const yearToDateRevenueResult = await Payment.aggregate([
            { $match: { status: 'completed', paymentDate: { $gte: yearStartDate, $lte: currentDate } } },
            { $group: { _id: null, total: { $sum: "$amount" } } }
        ]);
        const yearToDateRevenue = yearToDateRevenueResult.length > 0 ? yearToDateRevenueResult[0].total : 0;

        // Total revenue from subscriptions only
        const subscriptionRevenueResult = await Payment.aggregate([
            { $match: { status: 'completed', subscriptionPlan: { $ne: null }, paymentDate: { $gte: startDate, $lte: currentDate } } },
            { $group: { _id: null, total: { $sum: "$amount" } } }
        ]);
        const subscriptionRevenue = subscriptionRevenueResult.length > 0 ? subscriptionRevenueResult[0].total : 0;

        // 3. Calculate Expenses
        // Current period expenses
        const periodExpensesResult = await Expense.aggregate([
            { $match: { status: 'approved', date: { $gte: startDate, $lte: currentDate } } },
            { $group: { _id: null, total: { $sum: "$amount" } } }
        ]);
        const periodExpenses = periodExpensesResult.length > 0 ? periodExpensesResult[0].total : 0;

        // Year-to-date expenses
        const yearToDateExpensesResult = await Expense.aggregate([
            { $match: { status: 'approved', date: { $gte: yearStartDate, $lte: currentDate } } },
            { $group: { _id: null, total: { $sum: "$amount" } } }
        ]);
        const yearToDateExpenses = yearToDateExpensesResult.length > 0 ? yearToDateExpensesResult[0].total : 0;

        // 4. Outstanding Payments (pending or failed)
        const outstandingPayments = await Payment.aggregate([
            { $match: { status: { $in: ['pending', 'failed'] } } },
            { $group: { _id: null, total: { $sum: "$amount" } } }
        ]);
        
        // 5. Recent Transactions (within the period)
        const recentPayments = await Payment.find({ paymentDate: { $gte: startDate, $lte: currentDate } })
            .sort({ paymentDate: -1 })
            .limit(5)
            .populate('user', 'name')
            .populate('subscriptionPlan', 'name duration');
            
        const recentExpenses = await Expense.find({ date: { $gte: startDate, $lte: currentDate } })
            .sort({ date: -1 })
            .limit(5);
        
        // 6. Revenue by Subscription Plan
        const revenueByPlan = await Payment.aggregate([
            { $match: { status: 'completed', subscriptionPlan: { $ne: null }, paymentDate: { $gte: startDate, $lte: currentDate } } },
            { $lookup: { from: 'subscriptionplans', localField: 'subscriptionPlan', foreignField: '_id', as: 'planDetails' } },
            { $unwind: '$planDetails' },
            { $group: { _id: '$planDetails.name', revenue: { $sum: "$amount" }, count: { $sum: 1 } } },
            { $project: { plan: '$_id', revenue: 1, count: 1, _id: 0 } }
        ]);
        
        // 7. Expense breakdown by category (for the period)
        const expensesByCategory = await Expense.aggregate([
            { $match: { status: 'approved', date: { $gte: startDate, $lte: currentDate } } },
            { $group: { _id: '$category', total: { $sum: "$amount" }, count: { $sum: 1 } } },
            { $project: { category: '$_id', total: 1, count: 1, _id: 0 } },
            { $sort: { total: -1 } }
        ]);

        // Find Largest Expense Category
        const largestExpenseCategory = expensesByCategory.length > 0 
            ? { category: expensesByCategory[0].category, total: expensesByCategory[0].total } 
            : { category: 'N/A', total: 0 };

        // 8 & 9. Dynamic revenue and expense trends based on selected range
        let revenueTrend, expenseTrend;
        if (dateRange === 'month') {
            // Daily trend for current month
            revenueTrend = await Payment.aggregate([
                { $match: { status: 'completed', paymentDate: { $gte: startDate, $lte: currentDate } } },
                { $group: { _id: { day: { $dayOfMonth: '$paymentDate' } }, total: { $sum: '$amount' } } },
                { $sort: { '_id.day': 1 } },
                { $project: { month: { $toString: '$_id.day' }, total: 1, _id: 0 } }
            ]);
            expenseTrend = await Expense.aggregate([
                { $match: { status: 'approved', date: { $gte: startDate, $lte: currentDate } } },
                { $group: { _id: { day: { $dayOfMonth: '$date' } }, total: { $sum: '$amount' } } },
                { $sort: { '_id.day': 1 } },
                { $project: { month: { $toString: '$_id.day' }, total: 1, _id: 0 } }
            ]);
        } else {
            // Monthly trend for quarter or year
            const monthNames = [ '', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ];
            revenueTrend = await Payment.aggregate([
                { $match: { status: 'completed', paymentDate: { $gte: startDate, $lte: currentDate } } },
                { $group: { _id: { year: { $year: '$paymentDate' }, month: { $month: '$paymentDate' } }, total: { $sum: '$amount' } } },
                { $sort: { '_id.year': 1, '_id.month': 1 } },
                { $project: { month: { $concat: [ { $arrayElemAt: [ monthNames, '$_id.month' ] }, '-', { $toString: '$_id.year' } ] }, total: 1, _id: 0 } }
            ]);
            expenseTrend = await Expense.aggregate([
                { $match: { status: 'approved', date: { $gte: startDate, $lte: currentDate } } },
                { $group: { _id: { year: { $year: '$date' }, month: { $month: '$date' } }, total: { $sum: '$amount' } } },
                { $sort: { '_id.year': 1, '_id.month': 1 } },
                { $project: { month: { $concat: [ { $arrayElemAt: [ monthNames, '$_id.month' ] }, '-', { $toString: '$_id.year' } ] }, total: 1, _id: 0 } }
            ]);
        }
        
        // 10. Subscription plans data
        const subscriptionPlansData = await SubscriptionPlan.find().sort({ price: 1 });
        
        // Compile all data
        const dashboardData = {
            activeSubscriptions,
            newSubscriptions,
            cancellations,
            totalRevenue: {
                period: periodRevenue,
                year: yearToDateRevenue,
                subscriptions: subscriptionRevenue
            },
            totalExpenses: {
                period: periodExpenses,
                year: yearToDateExpenses
            },
            outstandingPayments: outstandingPayments.length > 0 ? outstandingPayments[0].total : 0,
            revenueGrowthPercentage,
            averageDailyRevenue,
            largestExpenseCategory,
            recentTransactions: {
                payments: recentPayments.map(payment => ({
                    id: payment._id,
                    date: payment.paymentDate,
                    customer: payment.user ? payment.user.name : 'Unknown',
                    description: payment.description,
                    amount: payment.amount,
                    status: payment.status,
                    paymentMethod: payment.paymentMethod
                })),
                expenses: recentExpenses.map(expense => ({
                    id: expense._id,
                    date: expense.date,
                    category: expense.category,
                    description: expense.description,
                    amount: expense.amount,
                    status: expense.status
                }))
            },
            revenueByPlan,
            expensesByCategory,
            trends: {
                revenue: revenueTrend,
                expenses: expenseTrend
            },
            subscriptionPlans: subscriptionPlansData.map(plan => ({
                id: plan._id,
                name: plan.name,
                price: plan.price,
                subscriberCount: plan.subscriberCount,
                description: plan.description,
                duration: plan.duration
            })),
            dateRange: {
                start: startDate,
                end: currentDate,
                type: dateRange,
                daysInPeriod: numberOfDaysInPeriod
            }
        };

        res.status(200).json(dashboardData);

    } catch (error) {
        console.error('Error fetching financial dashboard data:', error);
        res.status(500).json({ message: 'Error fetching dashboard data', error: error.message });
    }
};




// File: C:\y2s2ITP\SmartBin\backend\src\controllers\performanceController.js
const Performance = require('../models/Performance');
const User = require('../models/User');

// @desc    Create new performance review
// @route   POST /api/performance
// @access  Private/Admin
exports.createPerformanceReview = async (req, res) => {
  try {
    const { 
      staffId, 
      startDate, 
      endDate, 
      metrics, 
      feedback, 
      goals 
    } = req.body;
    
    // Check if staff exists
    const staff = await User.findById(staffId);
    
    if (!staff || staff.role !== 'staff') {
      return res.status(400).json({ message: 'Invalid staff member' });
    }
    
    // Create new performance review
    const review = new Performance({
      staff: staffId,
      reviewPeriod: {
        startDate,
        endDate
      },
      metrics,
      feedback,
      goals,
      reviewer: req.user.id
    });
    
    await review.save();
    
    res.status(201).json(review);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Get all performance reviews
// @route   GET /api/performance
// @access  Private/Admin
exports.getPerformanceReviews = async (req, res) => {
  try {
    const { staffId } = req.query;
    
    let query = {};
    
    if (staffId) {
      query.staff = staffId;
    }
    
    const reviews = await Performance.find(query)
      .populate('staff', 'name email')
      .populate('reviewer', 'name')
      .sort({ createdAt: -1 });
    
    res.json(reviews);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Get performance review by ID
// @route   GET /api/performance/:id
// @access  Private
exports.getPerformanceReviewById = async (req, res) => {
  try {
    const review = await Performance.findById(req.params.id)
      .populate('staff', 'name email')
      .populate('reviewer', 'name');
    
    if (!review) {
      return res.status(404).json({ message: 'Performance review not found' });
    }
    
    // Allow access if user is the reviewer, the staff being reviewed, or admin
    if (
      req.user.role !== 'admin' && 
      review.reviewer.toString() !== req.user.id && 
      review.staff._id.toString() !== req.user.id
    ) {
      return res.status(403).json({ message: 'Not authorized to access this review' });
    }
    
    res.json(review);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Update performance review
// @route   PUT /api/performance/:id
// @access  Private/Admin
exports.updatePerformanceReview = async (req, res) => {
  try {
    const { 
      metrics, 
      feedback, 
      goals 
    } = req.body;
    
    const review = await Performance.findById(req.params.id);
    
    if (!review) {
      return res.status(404).json({ message: 'Performance review not found' });
    }
    
    // Update fields
    if (metrics) review.metrics = metrics;
    if (feedback !== undefined) review.feedback = feedback;
    if (goals) review.goals = goals;
    
    await review.save();
    
    res.json(review);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Delete performance review
// @route   DELETE /api/performance/:id
// @access  Private/Admin
exports.deletePerformanceReview = async (req, res) => {
  try {
    const review = await Performance.findById(req.params.id);
    
    if (!review) {
      return res.status(404).json({ message: 'Performance review not found' });
    }
    
    await review.deleteOne();
    
    res.json({ message: 'Performance review removed' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Get staff member's performance reviews
// @route   GET /api/performance/my-reviews
// @access  Private/Staff
exports.getMyPerformanceReviews = async (req, res) => {
  try {
    const reviews = await Performance.find({ staff: req.user.id })
      .populate('reviewer', 'name')
      .sort({ createdAt: -1 });
    
    res.json(reviews);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Get performance summary by staff
// @route   GET /api/performance/summary
// @access  Private/Admin
exports.getPerformanceSummary = async (req, res) => {
  try {
    // Get all staff members
    const staffMembers = await User.find({ role: 'staff' }, '_id name email');
    
    // Get average performance for each staff
    const summaries = [];
    
    for (const staff of staffMembers) {
      const reviews = await Performance.find({ staff: staff._id });
      
      if (reviews.length === 0) {
        summaries.push({
          staff: {
            _id: staff._id,
            name: staff.name,
            email: staff.email
          },
          averageRating: 0,
          reviewCount: 0
        });
        continue;
      }
      
      // Calculate average rating
      const totalRating = reviews.reduce((acc, review) => acc + review.overallRating, 0);
      const averageRating = parseFloat((totalRating / reviews.length).toFixed(1));
      
      summaries.push({
        staff: {
          _id: staff._id,
          name: staff.name,
          email: staff.email
        },
        averageRating,
        reviewCount: reviews.length
      });
    }
    
    res.json(summaries);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};



// File: C:\y2s2ITP\SmartBin\backend\src\controllers\SubscriptionPlanController.js
const SubscriptionPlan = require('../models/SubscriptionPlan');

// @desc    Get all subscription plans
// @route   GET /api/subscription-plans
// @access  Private/financial_manager
exports.getSubscriptionPlans = async (req, res) => {
  try {
    const subscriptionPlans = await SubscriptionPlan.find().sort({ createdAt: -1 });
    res.json(subscriptionPlans);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Get subscription plan by ID
// @route   GET /api/subscription-plans/:id
// @access  Private/financial_manager
exports.getSubscriptionPlanById = async (req, res) => {
  try {
    const subscriptionPlan = await SubscriptionPlan.findById(req.params.id);
    
    if (!subscriptionPlan) {
      return res.status(404).json({ message: 'Subscription plan not found' });
    }
    
    res.json(subscriptionPlan);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Create new subscription plan
// @route   POST /api/subscription-plans
// @access  Private/financial_manager
exports.createSubscriptionPlan = async (req, res) => {
  try {
    const { name, price, subscriberCount, description, duration } = req.body;
    
    // Check if plan with the same name already exists
    const existingPlan = await SubscriptionPlan.findOne({ name });
    if (existingPlan) {
      return res.status(400).json({ message: 'A plan with this name already exists' });
    }
    
    const subscriptionPlan = await SubscriptionPlan.create({
      name,
      price,
      subscriberCount,
      description,
      duration
    });
    
    res.status(201).json(subscriptionPlan);
  } catch (error) {
    console.error(error);
    res.status(500).json({ 
      message: 'Server error',
      error: error.message 
    });
  }
};

// @desc    Update subscription plan
// @route   PUT /api/subscription-plans/:id
// @access  Private/financial_manager
exports.updateSubscriptionPlan = async (req, res) => {
  try {
    const { name, price, subscriberCount, description, duration } = req.body;
    
    // Check if plan exists
    let subscriptionPlan = await SubscriptionPlan.findById(req.params.id);
    
    if (!subscriptionPlan) {
      return res.status(404).json({ message: 'Subscription plan not found' });
    }
    
    // Check if we're trying to update to a name that already exists (except for this plan)
    if (name !== subscriptionPlan.name) {
      const existingPlan = await SubscriptionPlan.findOne({ name });
      if (existingPlan) {
        return res.status(400).json({ message: 'A plan with this name already exists' });
      }
    }
    
    // Update the plan
    subscriptionPlan = await SubscriptionPlan.findByIdAndUpdate(
      req.params.id,
      { name, price, subscriberCount, description, duration },
      { new: true, runValidators: true }
    );
    
    res.json(subscriptionPlan);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Delete subscription plan
// @route   DELETE /api/subscription-plans/:id
// @access  Private/financial_manager
exports.deleteSubscriptionPlan = async (req, res) => {
  try {
    const subscriptionPlan = await SubscriptionPlan.findById(req.params.id);
    
    if (!subscriptionPlan) {
      return res.status(404).json({ message: 'Subscription plan not found' });
    }
    
    await subscriptionPlan.deleteOne();
    
    res.json({ message: 'Subscription plan removed' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};



// File: C:\y2s2ITP\SmartBin\backend\src\controllers\userController.js
// backend/src/controllers/userController.js
const User = require('../models/User');
const Document = require('../models/Document');
const fs = require('fs');
const path = require('path');

// @desc    Get all users
// @route   GET /api/users
// @access  Private/Admin
exports.getUsers = async (req, res) => {
  try {
    const users = await User.find();
    res.json(users);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Get user by ID
// @route   GET /api/users/:id
// @access  Private/Admin
exports.getUserById = async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    
    if (user) {
      res.json(user);
    } else {
      res.status(404).json({ message: 'User not found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Get current user profile
// @route   GET /api/users/profile
// @access  Private
exports.getUserProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Get user documents if any
    const documents = await Document.find({ user: req.user.id });
    
    res.json({
      _id: user._id,
      name: user.name,
      email: user.email,
      role: user.role,
      createdAt: user.createdAt,
      documents: documents
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Update user profile
// @route   PUT /api/users/profile
// @access  Private
exports.updateUserProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Update basic info
    if (req.body.name) user.name = req.body.name;
    if (req.body.email) user.email = req.body.email;
    
    // Update password if provided
    if (req.body.password) {
      user.password = req.body.password;
    }
    
    const updatedUser = await user.save();
    
    res.json({
      _id: updatedUser._id,
      name: updatedUser.name,
      email: updatedUser.email,
      role: updatedUser.role
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Delete user account
// @route   DELETE /api/users/profile
// @access  Private
exports.deleteUserProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    if (user.role === 'staff') {
      return res.status(403).json({ message: 'Staff accounts cannot be deleted through this endpoint' });
    }
    
    // Delete user documents first
    await Document.deleteMany({ user: req.user.id });
    
    // Now delete the user
    await user.deleteOne();
    
    res.json({ message: 'User account deleted successfully' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};

// @desc    Delete user
// @route   DELETE /api/users/:id
// @access  Private/Admin
exports.deleteUser = async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    
    if (user) {
      await user.deleteOne();
      res.json({ message: 'User removed' });
    } else {
      res.status(404).json({ message: 'User not found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Server error' });
  }
};



// File: C:\y2s2ITP\SmartBin\backend\src\controllers\UserSubscriptionController.js
const UserSubscription = require('../models/UserSubscription');
const SubscriptionPlan = require('../models/SubscriptionPlan');
const User = require('../models/User');
const mongoose = require('mongoose');

// Helper function to add months to a date
const addMonths = (date, months) => {
  const result = new Date(date);
  result.setMonth(result.getMonth() + months);
  // Handle edge cases like Feb 29th
  if (result.getDate() < date.getDate()) {
    result.setDate(0); // Go to the last day of the previous month
  }
  return result;
};

// @desc    Create a new subscription for a user
// @route   POST /api/user-subscriptions
// @access  Private/financial_manager/admin
exports.createUserSubscription = async (req, res) => {
  const { userId, planId, startDate: customStartDate } = req.body;

  // Basic validation
  if (!userId || !planId) {
    return res.status(400).json({ message: 'User ID and Plan ID are required' });
  }
  if (!mongoose.Types.ObjectId.isValid(userId) || !mongoose.Types.ObjectId.isValid(planId)) {
    return res.status(400).json({ message: 'Invalid User ID or Plan ID format' });
  }

  try {
    // Check if user and plan exist
    const user = await User.findById(userId);
    const plan = await SubscriptionPlan.findById(planId);

    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    if (!plan) {
      return res.status(404).json({ message: 'Subscription plan not found' });
    }

    // Check if user already has an active subscription (optional, depends on business logic)
    // const existingActiveSubscription = await UserSubscription.findOne({ user: userId, status: 'active' });
    // if (existingActiveSubscription) {
    //   return res.status(400).json({ message: 'User already has an active subscription' });
    // }

    // Determine start date
    const startDate = customStartDate ? new Date(customStartDate) : new Date();
    if (isNaN(startDate.getTime())) {
        return res.status(400).json({ message: 'Invalid start date provided' });
    }

    // Calculate end date and next billing date based on plan duration
    let durationMonths = 1; // Default to Monthly
    switch (plan.duration) {
      case 'Quarterly':
        durationMonths = 3;
        break;
      case 'Semi-Annual':
        durationMonths = 6;
        break;
      case 'Annual':
        durationMonths = 12;
        break;
      // Default case 'Monthly' already set
    }

    const endDate = addMonths(startDate, durationMonths);
    const nextBillingDate = new Date(endDate); // First billing is at the end of the first period

    // Create the subscription
    const newSubscription = new UserSubscription({
      user: userId,
      subscriptionPlan: planId,
      startDate,
      endDate,
      status: 'active', // Default to active
      autoRenew: true, // Default to auto-renew true, can be changed later
      lastBillingDate: startDate, // Initial billing date is the start date
      nextBillingDate,
    });

    await newSubscription.save();

    // Optionally, increment subscriber count on the plan
    await SubscriptionPlan.findByIdAndUpdate(planId, { $inc: { subscriberCount: 1 } });

    res.status(201).json(newSubscription);

  } catch (error) {
    console.error('Error creating user subscription:', error);
    // Handle potential duplicate key errors if unique indexes are added later
    if (error.code === 11000) {
        return res.status(400).json({ message: 'Duplicate subscription detected.' });
    }
    res.status(500).json({ message: 'Server error while creating subscription' });
  }
};

// @desc    Get all subscriptions for a specific user
// @route   GET /api/user-subscriptions/user/:userId
// @access  Private/financial_manager/admin/owner
exports.getUserSubscriptions = async (req, res) => {
  const requestedUserId = req.params.userId;
  const loggedInUserId = req.user.id;
  const loggedInUserRole = req.user.role;

  // Validate userId format
  if (!mongoose.Types.ObjectId.isValid(requestedUserId)) {
    return res.status(400).json({ message: 'Invalid User ID format' });
  }

  // Check permissions: Allow if admin, financial manager, or the user is requesting their own subscriptions
  if (loggedInUserRole !== 'admin' && loggedInUserRole !== 'financial_manager' && loggedInUserId !== requestedUserId) {
    return res.status(403).json({ message: 'Not authorized to access these subscriptions' });
  }

  try {
    const subscriptions = await UserSubscription.find({ user: requestedUserId })
                                              .populate('subscriptionPlan', 'name price duration') // Populate plan details
                                              .populate('user', 'username email'); // Populate basic user details

    if (!subscriptions || subscriptions.length === 0) {
      // It's not an error if a user has no subscriptions, return empty array
      return res.status(200).json([]); 
    }

    res.status(200).json(subscriptions);

  } catch (error) {
    console.error('Error fetching user subscriptions:', error);
    res.status(500).json({ message: 'Server error while fetching subscriptions' });
  }
};

// @desc    Get a single subscription by ID
// @route   GET /api/user-subscriptions/:id
// @access  Private/financial_manager/admin/owner
exports.getUserSubscriptionById = async (req, res) => {
  const subscriptionId = req.params.id;
  const loggedInUserId = req.user.id;
  const loggedInUserRole = req.user.role;

  // Validate subscriptionId format
  if (!mongoose.Types.ObjectId.isValid(subscriptionId)) {
    return res.status(400).json({ message: 'Invalid Subscription ID format' });
  }

  try {
    const subscription = await UserSubscription.findById(subscriptionId)
                                              .populate('subscriptionPlan', 'name price duration description')
                                              .populate('user', 'username email');

    if (!subscription) {
      return res.status(404).json({ message: 'Subscription not found' });
    }

    // Check permissions: Allow if admin, financial manager, or the owner of the subscription
    if (loggedInUserRole !== 'admin' && loggedInUserRole !== 'financial_manager' && subscription.user._id.toString() !== loggedInUserId) {
      return res.status(403).json({ message: 'Not authorized to access this subscription' });
    }

    res.status(200).json(subscription);

  } catch (error) {
    console.error('Error fetching subscription by ID:', error);
    res.status(500).json({ message: 'Server error while fetching subscription' });
  }
};

// @desc    Update a subscription (e.g., status, autoRenew)
// @route   PUT /api/user-subscriptions/:id
// @access  Private/financial_manager/admin
exports.updateUserSubscription = async (req, res) => {
  const subscriptionId = req.params.id;
  const { status, autoRenew } = req.body;

  // Validate subscriptionId format
  if (!mongoose.Types.ObjectId.isValid(subscriptionId)) {
    return res.status(400).json({ message: 'Invalid Subscription ID format' });
  }

  // Validate incoming data (basic example)
  const allowedStatuses = ['active', 'expired', 'cancelled', 'pending'];
  if (status && !allowedStatuses.includes(status)) {
    return res.status(400).json({ message: 'Invalid status value' });
  }
  if (autoRenew !== undefined && typeof autoRenew !== 'boolean') {
    return res.status(400).json({ message: 'Invalid autoRenew value, must be true or false' });
  }

  try {
    const subscription = await UserSubscription.findById(subscriptionId);

    if (!subscription) {
      return res.status(404).json({ message: 'Subscription not found' });
    }

    // Update fields if they are provided in the request body
    if (status !== undefined) {
      subscription.status = status;
    }
    if (autoRenew !== undefined) {
      subscription.autoRenew = autoRenew;
    }
    // Add logic here if other fields like endDate need adjustment based on status change

    const updatedSubscription = await subscription.save();

    res.status(200).json(updatedSubscription);

  } catch (error) {
    console.error('Error updating subscription:', error);
    res.status(500).json({ message: 'Server error while updating subscription' });
  }
};

// @desc    Cancel (mark as cancelled) a subscription
// @route   DELETE /api/user-subscriptions/:id
// @access  Private/financial_manager/admin
exports.cancelUserSubscription = async (req, res) => {
  const subscriptionId = req.params.id;

  // Validate subscriptionId format
  if (!mongoose.Types.ObjectId.isValid(subscriptionId)) {
    return res.status(400).json({ message: 'Invalid Subscription ID format' });
  }

  try {
    const subscription = await UserSubscription.findById(subscriptionId);

    if (!subscription) {
      return res.status(404).json({ message: 'Subscription not found' });
    }

    // Prevent cancelling already cancelled subscriptions (optional)
    if (subscription.status === 'cancelled') {
        return res.status(400).json({ message: 'Subscription is already cancelled' });
    }

    const previousStatus = subscription.status;
    subscription.status = 'cancelled';
    subscription.autoRenew = false; // Ensure auto-renew is off
    // Optionally set endDate to now if cancelling prematurely
    // subscription.endDate = new Date(); 

    await subscription.save();

    // Decrement subscriber count only if it was previously active
    if (previousStatus === 'active') {
        await SubscriptionPlan.findByIdAndUpdate(subscription.subscriptionPlan, { $inc: { subscriberCount: -1 } });
    }

    res.status(200).json({ message: 'Subscription cancelled successfully' });

  } catch (error) {
    console.error('Error cancelling subscription:', error);
    res.status(500).json({ message: 'Server error while cancelling subscription' });
  }
};

// @desc    Get all active subscriptions (for admin/financial manager overview)
// @route   GET /api/user-subscriptions
// @access  Private/financial_manager/admin
exports.getAllActiveSubscriptions = async (req, res) => {
  try {
    const activeSubscriptions = await UserSubscription.find({ status: 'active' })
                                                    .populate('user', 'username email')
                                                    .populate('subscriptionPlan', 'name price')
                                                    .sort({ nextBillingDate: 1 }); // Sort by next billing date

    res.status(200).json(activeSubscriptions);

  } catch (error) {
    console.error('Error fetching all active subscriptions:', error);
    res.status(500).json({ message: 'Server error while fetching active subscriptions' });
  }
};




// File: C:\y2s2ITP\SmartBin\backend\src\middleware\authMiddleware.js
// backend/src/middleware/authMiddleware.js
const jwt = require('jsonwebtoken');
const User = require('../models/User');

// Protect routes
exports.protect = async (req, res, next) => {
  let token;
  
  // Check for token in headers
  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    try {
      // Get token from header
      token = req.headers.authorization.split(' ')[1];
      
      // Verify token
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      // Get user from the token
      req.user = await User.findById(decoded.id).select('-password');
      
      next();
    } catch (error) {
      console.error(error);
      res.status(401).json({ message: 'Not authorized, token failed' });
    }
  }
  
  if (!token) {
    res.status(401).json({ message: 'Not authorized, no token' });
  }
};

// Role authorization
exports.authorize = (...roles) => {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({
        message: `Role ${req.user ? req.user.role : 'undefined'} is not authorized to access this resource`
      });
    }
    next();
  };
};



// File: C:\y2s2ITP\SmartBin\backend\src\middleware\roleMiddleware.js
// Middleware factory to check if user has one of the allowed roles
const roleMiddleware = (allowedRoles) => {
  return (req, res, next) => {
    // Ensure req.user exists (should be set by authMiddleware)
    if (!req.user || !req.user.role) {
      return res.status(401).json({ message: 'Authentication required or user role not found' });
    }

    const userRole = req.user.role;

    // Check if the user's role is included in the allowed roles
    // Convert allowedRoles to lowercase for case-insensitive comparison if needed,
    // or ensure consistency in role naming (e.g., 'financial_manager' vs 'Financial Manager')
    // Assuming roles in the database match the strings in allowedRoles exactly for now.
    if (allowedRoles.includes(userRole)) {
      next(); // User has the required role, proceed to the next middleware/controller
    } else {
      console.warn(`Role access denied for user ${req.user.id} with role '${userRole}'. Required: ${allowedRoles.join(' or ')}`);
      return res.status(403).json({ message: 'Forbidden: Insufficient permissions' });
    }
  };
};

// Export the middleware factory function as the default export
module.exports = roleMiddleware;

// Example refactor for isFinancialManager middleware using the new roleMiddleware
exports.isFinancialManager = roleMiddleware(['financial_manager', 'admin']);



// File: C:\y2s2ITP\SmartBin\backend\src\models\Attendance.js
const mongoose = require('mongoose');

const attendanceSchema = new mongoose.Schema({
  staff: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  checkInTime: {
    type: Date,
    required: true
  },
  checkOutTime: {
    type: Date
  },
  totalHours: {
    type: Number,
    default: 0
  },
  status: {
    type: String,
    enum: ['Present', 'Absent', 'Late', 'Half-day', 'On Leave'],
    default: 'Present'
  },
  notes: {
    type: String
  },
  date: {
    type: Date,
    default: Date.now
  }
});

// Calculate total hours when checkout is recorded
attendanceSchema.pre('save', function(next) {
  if (this.checkInTime && this.checkOutTime) {
    const checkInTime = new Date(this.checkInTime);
    const checkOutTime = new Date(this.checkOutTime);
    
    // Calculate hours difference
    const diff = (checkOutTime - checkInTime) / (1000 * 60 * 60);
    this.totalHours = parseFloat(diff.toFixed(2));
  }
  next();
});

module.exports = mongoose.model('Attendance', attendanceSchema);



// File: C:\y2s2ITP\SmartBin\backend\src\models\Document.js
const mongoose = require('mongoose');

const documentSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  name: {
    type: String,
    required: [true, 'Document name is required'],
    trim: true
  },
  type: {
    type: String,
    required: [true, 'Document type is required'],
    enum: ['ID Card', 'Utility Bill', 'Driver License', 'Passport', 'Other'],
    default: 'Other'
  },
  filePath: {
    type: String,
    required: [true, 'File path is required']
  },
  mimeType: {
    type: String,
    required: [true, 'File type is required']
  },
  size: {
    type: Number,
    required: [true, 'File size is required']
  },
  uploadedAt: {
    type: Date,
    default: Date.now
  },
  verificationStatus: {
    type: String,
    enum: ['Pending', 'Verified', 'Rejected'],
    default: 'Pending'
  },
  verificationDate: {
    type: Date
  },
  verificationNotes: {
    type: String
  }
});

module.exports = mongoose.model('Document', documentSchema);



// File: C:\y2s2ITP\SmartBin\backend\src\models\Expense.js
const mongoose = require('mongoose');

const expenseSchema = new mongoose.Schema({
  category: {
    type: String,
    enum: ['fuel', 'maintenance', 'salaries', 'utilities', 'equipment', 'office', 'rent', 'marketing', 'insurance', 'taxes', 'other'],
    required: true
  },
  amount: {
    type: Number,
    required: [true, 'Expense amount is required']
  },
  description: {
    type: String,
    required: [true, 'Description is required']
  },
  date: {
    type: Date,
    default: Date.now
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  receipt: {
    type: String, // URL to uploaded receipt image
    default: null
  },
  status: {
    type: String,
    enum: ['pending', 'approved', 'rejected'],
    default: 'approved'
  },
  paymentMethod: {
    type: String,
    enum: ['cash', 'credit_card', 'bank_transfer', 'company_account', 'other'],
    default: 'company_account'
  },
  tags: [String]
});

// Add indexes for faster querying
expenseSchema.index({ date: -1 });
expenseSchema.index({ category: 1 });
expenseSchema.index({ createdBy: 1 });

module.exports = mongoose.model('Expense', expenseSchema);



// File: C:\y2s2ITP\SmartBin\backend\src\models\Payment.js
const mongoose = require('mongoose');

const paymentSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  amount: {
    type: Number,
    required: [true, 'Payment amount is required'],
  },
  description: {
    type: String,
    required: [true, 'Description is required']
  },
  paymentDate: {
    type: Date,
    default: Date.now
  },
  status: {
    type: String,
    enum: ['pending', 'completed', 'failed', 'refunded'],
    default: 'completed'
  },
  paymentMethod: {
    type: String,
    enum: ['credit_card', 'debit_card', 'bank_transfer', 'cash', 'paypal', 'other'],
    default: 'credit_card'
  },
  subscriptionPlan: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'SubscriptionPlan',
    required: false
  },
  invoiceNumber: {
    type: String,
    unique: true,
    default: () => 'INV-' + Math.floor(100000 + Math.random() * 900000)
  },
  transactionId: String
});

// Add indexes for faster querying
paymentSchema.index({ paymentDate: -1 });
paymentSchema.index({ status: 1 });
paymentSchema.index({ user: 1 });

module.exports = mongoose.model('Payment', paymentSchema);



// File: C:\y2s2ITP\SmartBin\backend\src\models\Performance.js
const mongoose = require('mongoose');

const performanceSchema = new mongoose.Schema({
  staff: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  reviewPeriod: {
    startDate: {
      type: Date,
      required: true
    },
    endDate: {
      type: Date,
      required: true
    }
  },
  metrics: {
    productivity: {
      type: Number,
      min: 0,
      max: 10,
      default: 0
    },
    quality: {
      type: Number,
      min: 0,
      max: 10,
      default: 0
    },
    reliability: {
      type: Number,
      min: 0,
      max: 10,
      default: 0
    },
    communication: {
      type: Number,
      min: 0,
      max: 10,
      default: 0
    },
    initiative: {
      type: Number,
      min: 0,
      max: 10,
      default: 0
    }
  },
  overallRating: {
    type: Number,
    min: 0,
    max: 10,
    default: 0
  },
  feedback: {
    type: String
  },
  goals: [String],
  reviewer: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Calculate overall rating from individual metrics
performanceSchema.pre('save', function(next) {
  const metrics = this.metrics;
  const totalScore = metrics.productivity + metrics.quality + 
    metrics.reliability + metrics.communication + metrics.initiative;
  
  this.overallRating = parseFloat((totalScore / 5).toFixed(1));
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model('Performance', performanceSchema);



// File: C:\y2s2ITP\SmartBin\backend\src\models\SubscriptionPlan.js
const mongoose = require('mongoose');

const subscriptionPlanSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Plan name is required'],
    trim: true,
    unique: true
  },
  price: {
    type: Number, // Changed from String to Number
    required: [true, 'Price is required'],
    min: [0, 'Price cannot be negative'] // Added validation for non-negative price
  },
  subscriberCount: {
    type: Number,
    default: 0
  },
  description: {
    type: String,
    default: 'This subscription plan includes basic waste collection services, weekly pickup, and access to the SmartBin mobile app.'
  },
  duration: {
    type: String,
    enum: ['Monthly', 'Quarterly', 'Semi-Annual', 'Annual'],
    default: 'Monthly'
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('SubscriptionPlan', subscriptionPlanSchema);



// File: C:\y2s2ITP\SmartBin\backend\src\models\User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema =  new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Please Enter Your Name'],
    trim: true,
  },
  email: {
    type: String,
    required: [true, 'Please Enter Your Email'],
    unique: true,
    match: [/^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/, 'Please enter a valid email']
  },
  password: {
    type: String,
    required: [true, 'Please Enter Your Password'],
    minlength: 8,
    select: false
  },
  role: {
    type: String,
    enum: ['Resident/Garbage_Buyer', 'staff', 'admin', 'financial_manager'],
    default: 'Resident/Garbage_Buyer'
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

//Encrypting Password Before Saving
userSchema.pre('save', async function(next){
  if(!this.isModified('password')){
    next();
  }

  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
});

// Match user entered password to hashed password in database
userSchema.methods.matchPassword = async function(enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);



// File: C:\y2s2ITP\SmartBin\backend\src\models\UserSubscription.js
const mongoose = require('mongoose');

const userSubscriptionSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  subscriptionPlan: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'SubscriptionPlan',
    required: true
  },
  startDate: {
    type: Date,
    default: Date.now
  },
  endDate: {
    type: Date,
    required: true
  },
  status: {
    type: String,
    enum: ['active', 'expired', 'cancelled', 'pending'],
    default: 'active'
  },
  autoRenew: {
    type: Boolean,
    default: true
  },
  lastBillingDate: {
    type: Date,
    default: Date.now
  },
  nextBillingDate: {
    type: Date,
    required: true
  }
});

// Add indexes for faster querying
userSubscriptionSchema.index({ user: 1 });
userSubscriptionSchema.index({ status: 1 });
userSubscriptionSchema.index({ nextBillingDate: 1 });

module.exports = mongoose.model('UserSubscription', userSubscriptionSchema);



// File: C:\y2s2ITP\SmartBin\backend\src\routes\attendanceRoutes.js
const express = require('express');
const router = express.Router();
const { 
  checkIn, 
  checkOut, 
  getMyAttendance, 
  getAllAttendance, 
  updateAttendance,
  getAttendanceSummary
} = require('../controllers/attendanceController');
const { protect, authorize } = require('../middleware/authMiddleware');

// All routes are protected
router.use(protect);

// Staff routes
router.post('/check-in', checkIn);
router.put('/check-out', checkOut);
router.get('/', getMyAttendance);

// Admin routes
router.get('/all', authorize('admin'), getAllAttendance);
router.put('/:id', authorize('admin'), updateAttendance);
router.get('/summary', authorize('admin'), getAttendanceSummary);

module.exports = router;



// File: C:\y2s2ITP\SmartBin\backend\src\routes\authRoutes.js
const express = require('express');
const router = express.Router();
const { registerUser, loginUser, getMe } = require('../controllers/authController');
const { protect } = require('../middleware/authMiddleware');

// User registration and login routes
router.post('/register', registerUser);
router.post('/login', loginUser);
router.get('/me', protect, getMe);

module.exports = router;



// File: C:\y2s2ITP\SmartBin\backend\src\routes\documentRoutes.js
const express = require('express');
const router = express.Router();
const { 
  uploadDocument, 
  getUserDocuments, 
  getDocumentById, 
  deleteDocument, 
  verifyDocument 
} = require('../controllers/documentController');
const { protect, authorize } = require('../middleware/authMiddleware');
const multer = require('multer');
const path = require('path');

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: function(req, file, cb) {
    cb(null, 'uploads/documents/');
  },
  filename: function(req, file, cb) {
    cb(null, `${req.user.id}-${Date.now()}${path.extname(file.originalname)}`);
  }
});

// Check file type
const fileFilter = (req, file, cb) => {
  const allowedTypes = ['image/jpeg', 'image/png', 'application/pdf'];
  
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only JPEG, PNG and PDF allowed'), false);
  }
};

const upload = multer({ 
  storage,
  fileFilter,
  limits: { fileSize: 5 * 1024 * 1024 } // 5MB max size
});

// All routes are protected with authentication
router.use(protect);

// Routes for documents
router.route('/')
  .get(getUserDocuments);

router.route('/upload')
  .post(upload.single('document'), uploadDocument);

router.route('/:id')
  .get(getDocumentById)
  .delete(deleteDocument);

// Admin only routes
router.route('/:id/verify')
  .put(authorize('admin'), verifyDocument);

module.exports = router;



// File: C:\y2s2ITP\SmartBin\backend\src\routes\financialRoutes.js
const express = require('express');
const financialController = require('../controllers/financialController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');

const router = express.Router();

// GET /api/financials/dashboard - Protected for Financial Manager and Admin
router.get(
    '/dashboard',
    authMiddleware.protect, // Use the protect method, not the entire middleware object
    roleMiddleware(['financial_manager', 'admin']), // Ensure user has the correct role
    financialController.getDashboardData
);

// Add other financial routes here (e.g., expenses, invoices)


module.exports = router;




// File: C:\y2s2ITP\SmartBin\backend\src\routes\performanceRoutes.js
const express = require('express');
const router = express.Router();
const { 
  createPerformanceReview, 
  getPerformanceReviews, 
  getPerformanceReviewById, 
  updatePerformanceReview, 
  deletePerformanceReview,
  getMyPerformanceReviews,
  getPerformanceSummary
} = require('../controllers/performanceController');
const { protect, authorize } = require('../middleware/authMiddleware');

// All routes are protected
router.use(protect);

// Staff routes
router.get('/my-reviews', getMyPerformanceReviews);

// Admin routes
router.route('/')
  .post(authorize('admin'), createPerformanceReview)
  .get(authorize('admin'), getPerformanceReviews);

router.get('/summary', authorize('admin'), getPerformanceSummary);

router.route('/:id')
  .get(getPerformanceReviewById) // Access controlled in controller
  .put(authorize('admin'), updatePerformanceReview)
  .delete(authorize('admin'), deletePerformanceReview);

module.exports = router;



// File: C:\y2s2ITP\SmartBin\backend\src\routes\subscriptionPlanRoutes.js
const express = require('express');
const router = express.Router();
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');
const subscriptionPlanController = require('../controllers/SubscriptionPlanController');

// GET all subscription plans (public)
router.get('/', subscriptionPlanController.getSubscriptionPlans);

// POST create a new subscription plan (Financial Manager or Admin only)
router.post(
    '/',
    authMiddleware.protect,
    roleMiddleware(['financial_manager', 'admin']),
    subscriptionPlanController.createSubscriptionPlan
);

// GET a specific subscription plan by ID (public)
router.get('/:id', subscriptionPlanController.getSubscriptionPlanById);

// PUT update a subscription plan (Financial Manager or Admin only)
router.put(
    '/:id',
    authMiddleware.protect,
    roleMiddleware(['financial_manager', 'admin']),
    subscriptionPlanController.updateSubscriptionPlan
);

// DELETE a subscription plan (Financial Manager or Admin only)
router.delete(
    '/:id',
    authMiddleware.protect,
    roleMiddleware(['financial_manager', 'admin']),
    subscriptionPlanController.deleteSubscriptionPlan
);

module.exports = router;



// File: C:\y2s2ITP\SmartBin\backend\src\routes\userRoutes.js
// backend/src/routes/userRoutes.js
const express = require('express');
const router = express.Router();
const { 
  getUsers, 
  getUserById, 
  updateUserProfile, 
  deleteUser,
  getUserProfile,
  deleteUserProfile
} = require('../controllers/userController');
const { protect, authorize } = require('../middleware/authMiddleware');

// User profile routes - all users can access their own profile
router.route('/profile')
  .get(protect, getUserProfile)
  .put(protect, updateUserProfile)
  .delete(protect, deleteUserProfile);

// Admin routes - only accessible by admins
router.route('/')
  .get(protect, authorize('admin'), getUsers);

router.route('/:id')
  .get(protect, authorize('admin'), getUserById)
  .delete(protect, authorize('admin'), deleteUser);

module.exports = router;



// File: C:\y2s2ITP\SmartBin\backend\src\routes\userSubscriptionRoutes.js
const express = require('express');
const router = express.Router();
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');
const userSubscriptionController = require('../controllers/UserSubscriptionController');

// Middleware for protecting routes
const { protect } = authMiddleware;

// Middleware for checking roles
const requireAdminOrFinancialManager = roleMiddleware(['admin', 'financial_manager']);

// Route to get all active subscriptions (Admin/Financial Manager only)
router.get(
    '/', 
    protect, 
    requireAdminOrFinancialManager, 
    userSubscriptionController.getAllActiveSubscriptions
);

// Route to create a new subscription (Admin/Financial Manager only)
router.post(
    '/', 
    protect, 
    requireAdminOrFinancialManager, 
    userSubscriptionController.createUserSubscription
);

// Route to get subscriptions for a specific user (Admin/Financial Manager or the user themselves)
// TODO: Add logic in controller to check if req.user.id matches :userId for ownership check
router.get(
    '/user/:userId', 
    protect, 
    // roleMiddleware(['admin', 'financial_manager', 'Resident/Garbage_Buyer', 'staff']), // Allow users to see their own - needs controller logic
    userSubscriptionController.getUserSubscriptions
);

// Route to get a single subscription by ID (Admin/Financial Manager or the user themselves)
// TODO: Add logic in controller to check ownership
router.get(
    '/:id', 
    protect, 
    // roleMiddleware(['admin', 'financial_manager', 'Resident/Garbage_Buyer', 'staff']), // Allow users to see their own - needs controller logic
    userSubscriptionController.getUserSubscriptionById
);

// Route to update a subscription (Admin/Financial Manager only)
router.put(
    '/:id', 
    protect, 
    requireAdminOrFinancialManager, 
    userSubscriptionController.updateUserSubscription
);

// Route to cancel a subscription (Admin/Financial Manager only)
router.delete(
    '/:id', 
    protect, 
    requireAdminOrFinancialManager, 
    userSubscriptionController.cancelUserSubscription
);

module.exports = router;




// File: C:\y2s2ITP\SmartBin\backend\src\scripts\createTestUsers.js
//
// Required libraries
const bcryptjs = require('bcryptjs');  // CHANGE: Use bcryptjs instead of bcrypt
const mongoose = require('mongoose');   
const User = require('../models/User');  
const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../../.env') });

// Main function to create test users
const createTestUsers = async () => {
  try {
    // Connect to MongoDB using .env file
    console.log('Connecting to MongoDB...');
    
    // Get connection string from environment variable
    const MONGODB_URI = process.env.MONGODB_URI;
    
    if (!MONGODB_URI) {
      console.error('Error: MONGODB_URI environment variable not set.');
      process.exit(1); // Exit if connection string is missing
    }
    
    // Hide actual connection details when logging
    console.log('Using MongoDB connection from environment');
    await mongoose.connect(MONGODB_URI);
    console.log('Connected to MongoDB successfully');

    // Define test users with different roles
    const testUsers = [
      {
        name: 'Admin User',
        email: 'admin@smartbin.com',
        password: 'Admin123!',
        role: 'admin'
      },
      {
        name: 'Staff Member',
        email: 'staff@smartbin.com',
        password: 'Staff123!',
        role: 'staff'
      },
      {
        name: 'Financial Manager',
        email: 'finance@smartbin.com',
        password: 'Finance123!',
        role: 'financial_manager'
      }
    ];

    // Process each test user
    for (const user of testUsers) {
      // Check if user already exists
      const existingUser = await User.findOne({ email: user.email });
      
      if (existingUser) {
        console.log(`User ${user.email} already exists. Updating role to ${user.role}`);
        existingUser.role = user.role;
        await existingUser.save();
        continue;
      }
      
      // Hash password for new user (USING BCRYPTJS!)
      const salt = await bcryptjs.genSalt(10);
      const hashedPassword = await bcryptjs.hash(user.password, salt);
      
      // Create new user
      await User.create({
        name: user.name,
        email: user.email,
        password: hashedPassword,
        role: user.role
      });
      
      console.log(`Created ${user.role} user: ${user.email}`);
    }

    console.log('Test users created successfully!');
  } catch (error) {
    console.error('Error creating test users:', error.message);
  } finally {
    // Always close the connection when done
    if (mongoose.connection.readyState !== 0) {
      await mongoose.connection.close();
      console.log('Database connection closed');
    }
  }
};

// Run the function
createTestUsers();



// File: C:\y2s2ITP\SmartBin\backend\src\scripts\recreateUsers.js
const mongoose = require('mongoose');
const User = require('../models/User');
require('dotenv').config({ path: '../../.env' });

const recreateUsers = async () => {
    try {
      await mongoose.connect(process.env.MONGODB_URI || 'mongodb+srv://sasindu10:12345@smartbincluster.ij7fd.mongodb.net/smartbin?retryWrites=true&w=majority&appName=SmartBinCluster');
      console.log('Connected to MongoDB');
    
    // Test users with plain-text passwords.
    const testUsers = [
      { name: 'Admin User', email: 'admin@smartbin.com', password: 'Admin123!', role: 'admin' },
      { name: 'Staff Member', email: 'staff@smartbin.com', password: 'Staff123!', role: 'staff' },
      { name: 'Financial Manager', email: 'finance@smartbin.com', password: 'Finance123!', role: 'financial_manager' }
    ];
    
    // Delete any existing test users
    for (const user of testUsers) {
      await User.deleteOne({ email: user.email });
      console.log(`Deleted user if exists: ${user.email}`);
    }
    
    // Create new users (the pre-save hook will hash the passwords)
    for (const user of testUsers) {
      const newUser = await User.create(user);
      console.log(`Recreated user: ${newUser.email}`);
    }
    
  } catch (error) {
    console.error('Error:', error.message);
  } finally {
    await mongoose.connection.close();
    console.log('Database connection closed');
  }
};

recreateUsers();



// File: C:\y2s2ITP\SmartBin\backend\src\scripts\seedFinancialData.js
/**
 * Seed Financial Data Script
 * 
 * This script populates the database with realistic financial data for the SmartBin application.
 * It creates:
 * 1. Subscription plans (if they don't exist)
 * 2. Subscription records for users
 * 3. Payment transactions
 * 4. Expense records
 * 
 * Use for development, testing, and demo purposes.
 */

const mongoose = require('mongoose');
const path = require('path');
require('dotenv').config({ path: path.resolve(__dirname, '../../.env') });

// Import models
const User = require('../models/User');
const SubscriptionPlan = require('../models/SubscriptionPlan');
const UserSubscription = require('../models/UserSubscription');
const Payment = require('../models/Payment');
const Expense = require('../models/Expense');

// Utility function to generate a random date between two dates
const randomDate = (start, end) => {
  return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
};

// Utility function to generate random number between min and max
const randomNumber = (min, max) => {
  return Math.floor(Math.random() * (max - min + 1) + min);
};

// Utility function to get a random element from an array
const randomElement = (array) => {
  return array[Math.floor(Math.random() * array.length)];
};

// Utility function to add days to a date
const addDays = (date, days) => {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
};

// Utility function to add months to a date
const addMonths = (date, months) => {
  const result = new Date(date);
  result.setMonth(result.getMonth() + months);
  return result;
};

// Main seeding function
const seedFinancialData = async () => {
  try {
    // Connect to MongoDB
    console.log('Connecting to MongoDB...');
    const MONGODB_URI = process.env.MONGODB_URI;
    if (!MONGODB_URI) {
      throw new Error("MONGODB_URI environment variable not set. Please check your .env file.");
    }
    
    await mongoose.connect(MONGODB_URI);
    console.log('MongoDB Connected');

    // Get financial manager user (needed for expense creation)
    const financialManager = await User.findOne({ role: 'financial_manager' });
    if (!financialManager) {
      console.log('No financial manager found. Please run createTestUsers.js first.');
      return;
    }

    // Get all users (residents/customers)
    const users = await User.find({ role: { $ne: 'admin', $ne: 'financial_manager', $ne: 'staff' } });
    if (users.length === 0) {
      // Create some test customer users if none exist
      console.log('No customer users found. Creating some test customers...');
      
      const customerNames = [
        'John Smith', 'Emma Wilson', 'Michael Brown', 'Sophia Davis', 
        'William Johnson', 'Olivia Taylor', 'James Miller', 'Ava Anderson',
        'Robert Thomas', 'Isabella Jackson', 'Daniel White', 'Mia Harris',
        'David Martinez', 'Charlotte Thompson', 'Joseph Garcia', 'Amelia Robinson'
      ];
      
      for (let i = 0; i < customerNames.length; i++) {
        const newUser = new User({
          name: customerNames[i],
          email: customerNames[i].toLowerCase().replace(' ', '.') + '@example.com',
          password: '$2a$10$XA9UJn3AJlszUVCjsxAN1uhkZ8qzBqOn9jBp0ZBOg5AfU9Hgu5P5W', // Password123!
          role: 'Resident/Garbage_Buyer',
          createdAt: randomDate(new Date(2024, 0, 1), new Date())
        });
        
        await newUser.save();
        console.log(`Created test customer: ${newUser.name}`);
      }
      
      // Fetch the newly created users
      users.push(...await User.find({ role: 'Resident/Garbage_Buyer' }));
    }

    // 1. Create subscription plans if they don't exist
    console.log('Setting up subscription plans...');
    
    const subscriptionPlans = [
      {
        name: 'Basic',
        price: '49.99',
        description: 'Basic waste collection service with weekly pickup and app access.',
        duration: 'Monthly'
      },
      {
        name: 'Standard',
        price: '79.99',
        description: 'Enhanced service with twice-weekly pickup, recycling options, and advanced app features.',
        duration: 'Monthly'
      },
      {
        name: 'Premium',
        price: '99.99',
        description: 'Premium service with unlimited pickup, priority service, recycling and composting options, and full app features.',
        duration: 'Monthly'
      },
      {
        name: 'Business',
        price: '199.99',
        description: 'Comprehensive waste management solution for small to medium businesses with daily collection and dedicated support.',
        duration: 'Monthly'
      }
    ];
    
    // Create plans if they don't exist
    for (const plan of subscriptionPlans) {
      const existingPlan = await SubscriptionPlan.findOne({ name: plan.name });
      
      if (existingPlan) {
        console.log(`Subscription plan ${plan.name} already exists.`);
      } else {
        await SubscriptionPlan.create(plan);
        console.log(`Created subscription plan: ${plan.name}`);
      }
    }
    
    // Get all plans after creation
    const allPlans = await SubscriptionPlan.find({});
    
    // 2. Create user subscriptions
    console.log('Creating user subscriptions...');
    
    // Get current date for subscription calculations
    const currentDate = new Date(); // Use the actual current date
    const sixMonthsAgo = new Date(currentDate.getFullYear(), currentDate.getMonth() - 6, currentDate.getDate());
    
    // Clear existing user subscriptions 
    await UserSubscription.deleteMany({});
    
    // Create realistic distribution of plans among users
    for (const user of users) {
      // Randomly select a plan with weighted distribution
      // Premium and Business plans are less common
      const planWeights = [0.4, 0.3, 0.2, 0.1]; // Probabilities for Basic, Standard, Premium, Business
      const randomValue = Math.random();
      let cumulativeProbability = 0;
      let selectedPlanIndex = 0;
      
      for (let i = 0; i < planWeights.length; i++) {
        cumulativeProbability += planWeights[i];
        if (randomValue <= cumulativeProbability) {
          selectedPlanIndex = i;
          break;
        }
      }
      
      const selectedPlan = allPlans[selectedPlanIndex];
      
      // Random start date between 6 months ago and now
      const startDate = randomDate(sixMonthsAgo, currentDate);
      
      // Determine duration based on plan
      let durationInMonths = 1; // Default monthly
      
      if (Math.random() > 0.7) {
        // 30% chance of longer subscription
        if (selectedPlan.duration === 'Monthly') {
          // Some users choose longer terms for monthly plans
          durationInMonths = randomElement([3, 6, 12]);
        }
      }
      
      // Calculate end and next billing dates
      const endDate = addMonths(startDate, durationInMonths);
      let nextBillingDate = new Date(startDate);
      
      // If the subscription would have already ended, create a renewed one
      if (endDate < currentDate) {
        // This is a renewal
        const renewalCycles = Math.floor((currentDate - startDate) / (durationInMonths * 30 * 24 * 60 * 60 * 1000)) + 1;
        nextBillingDate = addMonths(startDate, durationInMonths * renewalCycles);
      }
      
      // Create the subscription
      const subscription = new UserSubscription({
        user: user._id,
        subscriptionPlan: selectedPlan._id,
        startDate,
        endDate: addMonths(nextBillingDate, durationInMonths),
        status: 'active',
        autoRenew: Math.random() > 0.1, // 90% have auto-renew on
        lastBillingDate: startDate,
        nextBillingDate
      });
      
      await subscription.save();
      console.log(`Created subscription for user ${user.name}: ${selectedPlan.name} plan`);
      
      // Update subscription count on the plan
      await SubscriptionPlan.findByIdAndUpdate(
        selectedPlan._id, 
        { $inc: { subscriberCount: 1 } }
      );
    }
    
    // 3. Create payment records
    console.log('Generating payment history...');
    
    // Clear existing payments
    await Payment.deleteMany({});
    
    // Get all active subscriptions
    const activeSubscriptions = await UserSubscription.find({ status: 'active' })
      .populate('user')
      .populate('subscriptionPlan');
    
    // Generate payment history for each active subscription
    for (const subscription of activeSubscriptions) {
      // Calculate how many payment cycles have occurred up to the current date
      const startDate = new Date(subscription.startDate);
      // Ensure we cover cycles potentially ending *in* the current month
      const monthsElapsed = Math.max(0, Math.floor((currentDate.getTime() - startDate.getTime()) / (30 * 24 * 60 * 60 * 1000))); // Approximate months
      const paymentCyclesToGenerate = monthsElapsed + 1; // Generate for current cycle too

      // Generate a payment for each billing cycle that has occurred or is current
      for (let i = 0; i < paymentCyclesToGenerate; i++) {
        const paymentDate = addMonths(startDate, i);

        // Only create payments up to the current date
        if (paymentDate > currentDate) continue;
        
        // Determine payment amount based on plan price
        const price = parseFloat(subscription.subscriptionPlan.price);
        if (isNaN(price)) {
          console.error(`Invalid price for subscription plan: ${subscription.subscriptionPlan.name}`);
          continue; // Skip this payment if the price is invalid
        }
        const amount = price;
        
        // Generate some overdue and pending payments (10% chance)
        const status = Math.random() > 0.9 
          ? randomElement(['pending', 'failed']) 
          : 'completed';
        
        // Create payment record
        const payment = new Payment({
          user: subscription.user._id,
          amount,
          description: `${subscription.subscriptionPlan.name} Plan - ${subscription.subscriptionPlan.duration}`,
          paymentDate,
          status,
          paymentMethod: randomElement(['credit_card', 'debit_card', 'bank_transfer', 'paypal']),
          subscriptionPlan: subscription.subscriptionPlan._id
        });
        
        await payment.save();
      }
      
      console.log(`Created payment history for ${subscription.user.name}`);
    }
    
    // Guarantee at least 3 completed payments for the current month
    const currentMonthStart = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
    const validPlans = allPlans.filter(p => !isNaN(parseFloat(p.price)));
    for (let i = 0; i < 3; i++) {
      const randomUser = randomElement(users);
      const randomPlan = randomElement(validPlans);
      if (!randomPlan) continue; // skip if no valid plan
      const payment = new Payment({
        user: randomUser._id,
        amount: parseFloat(randomPlan.price),
        description: `${randomPlan.name} Plan - ${randomPlan.duration}`,
        paymentDate: addDays(currentMonthStart, Math.floor(Math.random() * (currentDate.getDate()))),
        status: 'completed',
        paymentMethod: randomElement(['credit_card', 'debit_card', 'bank_transfer', 'cash', 'paypal', 'other']),
        subscriptionPlan: randomPlan._id
      });
      await payment.save();
    }
    
    // 4. Create some one-time payments not related to subscriptions
    console.log('Generating one-time payments...');

    // Define default one-time payment descriptions
    const oneTimePaymentDescriptions = [
      'Service fee',
      'Consultation fee',
      'Setup fee',
      'Installation fee',
      'Penalty fee'
    ];

    // Generate a larger variety of one-time payments for diverse revenue streams
    const oneTimePaymentCount = 100;
    for (let i = 0; i < oneTimePaymentCount; i++) {
      const randomUser = randomElement(users);
      const paymentDate = randomDate(sixMonthsAgo, currentDate);
      const amount = randomNumber(30, 500); // expanded range for larger payments
      const oneTimeDescriptions = [
        ...oneTimePaymentDescriptions,
        'Emergency pickup service',
        'Late payment fee',
        'Bulk waste disposal fee',
        'Additional recycling service'
      ];
      const payment = new Payment({
        user: randomUser._id,
        amount,
        description: randomElement(oneTimeDescriptions),
        paymentDate,
        status: randomElement(['completed','completed','completed','pending','failed']),
        paymentMethod: randomElement(['credit_card', 'debit_card', 'bank_transfer', 'cash', 'paypal', 'other']),
        subscriptionPlan: null
      });
      
      await payment.save();
    }
    
    console.log('Created one-time payments');
    
    // 5. Create expense records
    console.log('Generating expense records...');
    
    // Clear existing expenses
    await Expense.deleteMany({});
    
    // Define expense categories and their relative frequencies and ranges
    const expenseCategories = [
      { category: 'fuel', frequency: 0.15, min: 200, max: 800 },
      { category: 'maintenance', frequency: 0.15, min: 100, max: 1000 },
      { category: 'salaries', frequency: 0.3, min: 1500, max: 5000 },
      { category: 'utilities', frequency: 0.1, min: 300, max: 800 },
      { category: 'equipment', frequency: 0.1, min: 200, max: 2000 },
      { category: 'office', frequency: 0.05, min: 50, max: 300 },
      { category: 'rent', frequency: 0.05, min: 1000, max: 3000 },
      { category: 'marketing', frequency: 0.05, min: 200, max: 1500 },
      { category: 'insurance', frequency: 0.03, min: 500, max: 2000 },
      { category: 'taxes', frequency: 0.02, min: 500, max: 5000 },
    ];
    
    // Expense descriptions for each category
    const expenseDescriptions = {
      fuel: ['Vehicle refueling', 'Truck fleet fuel', 'Collection vehicle diesel', 'Transportation fuel'],
      maintenance: ['Vehicle maintenance', 'Equipment repair', 'Bin repair services', 'Facility maintenance', 'Machinery servicing'],
      salaries: ['Staff payroll', 'Employee benefits', 'Contractor payments', 'Overtime payments', 'Management salaries'],
      utilities: ['Electricity bill', 'Water services', 'Internet and phone', 'Gas bill', 'Waste facility utilities'],
      equipment: ['New sorting equipment', 'Replacement bins', 'Office equipment', 'Safety equipment', 'Processing machinery'],
      office: ['Office supplies', 'Stationery', 'Cleaning supplies', 'Break room supplies', 'Small equipment'],
      rent: ['Office space rent', 'Warehouse rental', 'Storage facility', 'Equipment leasing', 'Temporary space rental'],
      marketing: ['Promotional materials', 'Digital advertising', 'Community outreach', 'Website maintenance', 'Marketing campaign'],
      insurance: ['Vehicle insurance', 'Liability coverage', 'Property insurance', 'Worker compensation', 'Business insurance'],
      taxes: ['Property tax', 'Business tax payment', 'Regulatory fees', 'Environmental compliance fees', 'Local taxes']
    };
    
    // Generate monthly expenses for each category for the past 12 months up to the current month
    const firstExpenseMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() - 11, 1); // Start 11 months before

    for (let monthOffset = 0; monthOffset <= 11; monthOffset++) {
      const targetMonthDate = addMonths(firstExpenseMonth, monthOffset);
      // Ensure we don't generate for future months beyond the current one
      if (targetMonthDate.getFullYear() > currentDate.getFullYear() || 
          (targetMonthDate.getFullYear() === currentDate.getFullYear() && targetMonthDate.getMonth() > currentDate.getMonth())) {
          continue;
      }

      // For each expense category
      for (const expenseCat of expenseCategories) {
        // Create 2-5 expenses per category per month for richer data
        const numExpenses = randomNumber(2, 5);

        for (let i = 0; i < numExpenses; i++) {
          // Generate a random date within the target month, but not exceeding the current date
          const daysInMonth = new Date(targetMonthDate.getFullYear(), targetMonthDate.getMonth() + 1, 0).getDate();
          const randomDay = randomNumber(1, daysInMonth);
          let expenseDate = new Date(targetMonthDate.getFullYear(), targetMonthDate.getMonth(), randomDay);

          // If this is the current month, ensure the date is not in the future
          if (targetMonthDate.getFullYear() === currentDate.getFullYear() && targetMonthDate.getMonth() === currentDate.getMonth()) {
            expenseDate.setDate(Math.min(randomDay, currentDate.getDate()));
          }
          
          // Ensure expenseDate is not before sixMonthsAgo (optional, but keeps consistency)
          if (expenseDate < sixMonthsAgo) expenseDate = new Date(sixMonthsAgo);

          const amount = randomNumber(expenseCat.min, expenseCat.max);
          const description = randomElement(expenseDescriptions[expenseCat.category]);
          
          const expense = new Expense({
            category: expenseCat.category,
            amount,
            description: `${description} - ${expenseDate.toLocaleDateString('en-US', { month: 'long' })}`,
            date: expenseDate,
            createdBy: financialManager._id,
            status: randomElement(['approved', 'approved', 'approved', 'approved', 'pending']), // 80% approved
            paymentMethod: randomElement(['company_account', 'credit_card', 'bank_transfer'])
          });
          
          await expense.save();
        }
      }
      
      console.log(`Created expenses for ${targetMonthDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}`);
    }
    
    // Guarantee at least 3 approved expenses for the current month
    const expenseCategoriesList = ['fuel', 'maintenance', 'salaries', 'utilities', 'equipment', 'office', 'rent', 'marketing', 'insurance', 'taxes'];
    for (let i = 0; i < 3; i++) {
      const expense = new Expense({
        category: randomElement(expenseCategoriesList),
        amount: randomNumber(200, 2000),
        description: `Seeded expense for dashboard (${i + 1})`,
        date: addDays(currentMonthStart, Math.floor(Math.random() * (currentDate.getDate()))),
        createdBy: financialManager._id,
        status: 'approved',
        paymentMethod: randomElement(['company_account', 'credit_card', 'bank_transfer'])
      });
      await expense.save();
    }
    
    // Calculate and log summary statistics
    const totalPayments = await Payment.countDocuments();
    const totalExpenses = await Expense.countDocuments();
    const activeSubscriptionsCount = await UserSubscription.countDocuments({ status: 'active' });
    
    console.log('\n=== Financial Data Seeding Complete ===');
    console.log(`Created ${totalPayments} payment records`);
    console.log(`Created ${totalExpenses} expense records`);
    console.log(`Set up ${activeSubscriptionsCount} active subscriptions`);
    console.log('\nYour dashboard should now be populated with realistic data!');
    
  } catch (error) {
    console.error('Error seeding financial data:', error);
  } finally {
    // Close database connection
    if (mongoose.connection.readyState !== 0) {
      await mongoose.connection.close();
      console.log('Database connection closed');
    }
  }
};

// Run the seeding function
seedFinancialData();



// File: C:\y2s2ITP\SmartBin\backend\src\scripts\verifyPasswords.js
const mongoose = require('mongoose');
const bcryptjs = require('bcryptjs');
const User = require('../models/User');

const verifyPasswords = async () => {
  try {
    // Connect to MongoDB
    await mongoose.connect('mongodb+srv://sasindu10:12345@smartbincluster.ij7fd.mongodb.net/smartbin?retryWrites=true&w=majority&appName=SmartBinCluster');
    console.log('Connected to MongoDB');
    
    // Test credentials
    const testUsers = [
      { email: 'admin@smartbin.com', password: 'Admin123!' },
      { email: 'staff@smartbin.com', password: 'Staff123!' },
      { email: 'finance@smartbin.com', password: 'Finance123!' }
    ];
    
    for (const user of testUsers) {
      // Find user and explicitly select password
      const foundUser = await User.findOne({ email: user.email }).select('+password');
      
      if (!foundUser) {
        console.log(`❌ User not found: ${user.email}`);
        continue;
      }
      
      console.log(`Found user: ${foundUser.email} (${foundUser.role})`);
      console.log(`Password hash: ${foundUser.password ? foundUser.password.substring(0, 20) + '...' : 'NO PASSWORD FOUND'}`);
      
      // Direct bcryptjs comparison
      if (foundUser.password) {
        const passwordMatches = await bcryptjs.compare(user.password, foundUser.password);
        console.log(`Password direct comparison: ${passwordMatches ? '✅ MATCH' : '❌ NO MATCH'}`);
      } else {
        console.log('⚠️ No password hash found for comparison');
      }
      
      console.log('-------------------');
    }
    
    mongoose.connection.close();
  } catch (error) {
    console.error('Error:', error);
    mongoose.connection.close();
  }
};

verifyPasswords();



